<html>
<head>
<title>CS296 Project Report</title>
<style>
h2{margin-left: 5%;}
</style>
</head>
<body>
<h1 style="margin-bottom:10;"><center> Group 1 Project Report </center></h1>
<table align=center frame=none cellspacing=5 width=1300>
<tr>
<td><center> Siddharth Patel </center></td>
<td><center> Ramprakash K </center></td>
<td><center> Viplov Jain </center></td>
</tr>
<tr>
<td><center> 120050001 </center></td>
<td><center> 120050083 </center></td>
<td><center> 120050084 </center></td>
</tr>
<tr>
<td><center> sidd@cse.iitb.ac.in </center></td>
<td><center> ramprakash@cse.iitb.ac.in </center></td>
<td><center> viplov@cse.iitb.ac.in </center></td>
</tr>
</table>
<ul style="list-style:none"><font size="5">
<li><h2>Introduction</h2></li>In this document we will provide a detailed analysis of our CS296 project. It contains a system of gears kept in motion by a perpetual wheel that is run by a motor.
<li><h2>Physics behind the simulation.</h2></li>
<ol>
<li><b>Perpetual Motion</b></li>
Perpetual motion is the action of the device that once set in motion would continue in motion forever, with no additional energy required to maintain it. Such devices are impractical in real life due to energy loses due to friction,however those machines which are close to perfect perpetual motion can be used to drive other engines such as clocks/turbines. This idea has been implemented to drive our mechanical clock. Even in Box2D, we were not able to simulate a perfect perpetual motion machine since the restitution of the bodies were to be less than 1 which meant that there would be energy loss. Hence, we had to attach a motor to keep it in motion.
<li><b>Perpetual Wheel</b></li>
The wheel we used in this project is the modified version of the Bhaskara Wheel which was one of the most earliest recorded man-made perpetual wheel. The idea was that the moment of inertia about the centre of the weights (spheres) that are descending is more than that of the weights that are ascending (since they are farther away from the centre) and hence, the wheel is supposed to experience continuous torque in a single direction.
<center><img src="./images/pic.png"></center>
<center><p><font size="3">Figure 1: Perpetual Wheel Design</font></p></center>
<li><b>Gear Clock</b></li>
Mechanical clocks are made using gears, in which there are gears for each hand of the clock, and intermediate gears to connect them in appropriate ratios so that they rotate in the exact angular velocity as they denote.
<center><img src="./images/gear_clock.jpg"></center>
<center><p><font size="3">Figure 2: Gear Clock Design</font></p></center>
Our perpetual wheel is attached to a motor that drives it at an angular speed of <i>pi/5</i>.<br>
We have a 10 tooth gear attached to our perpetual wheel that drives the 60 tooth gear denoting the seconds hand.<br>
The 60 tooth gear has a 9 tooth gear attached to it which drives a 90 tooth intermediate gear.<br>
The 90 tooth gear has a 12 tooth gear attached to it which drives the 72 tooth gear denoting the minute hand.<br>
The 72 tooth gear has a 24 tooth gear attached to it which drives a 72 tooth intermediate gear.<br>
The 72 tooth gear has a 18 tooth gear attached to it which drives the 72 tooth gear denoting the hour hand.<br>
<br>
Our perpetual wheel takes 10 seconds to complete 1 rotation, i.e., 10 seconds to rotate 10 gear teeth.<br>
So in 1 second, it would have moved 1 tooth of the seconds hand gear.<br>
In 10 rotations of the seconds hand gear, the inner gear would have moved moved 90 teeth of the intermediate gear, i.e., 1 rotation.<br>
In 6 rotations of the intermediate gear, the inner gear would have moved 72 teeth of the minute hand gear, i.e., 1 rotation.<br>
Thus, in 60 rotations of the seconds hand gear, the minute hand gear would have moved 1 full rotation.<br>
Similarly, in 3 rotations of the minute hand gear, the inner gear would have moved 72 teeth of the intermediate gear, i.e., 1 rotation.<br>
And in 4 rotations of the intermediate gear, the inner gear would have moved 72 teeth of the hour hand gear, i.e., 1 rotation.<br>
Thus, in 12 rotations of the minute hand gear, the hour hand gear would have moved 1 full rotation.<br>
<br>
<center><img src="./images/clock.png"></center>
<center><p><font size="3">Figure 3: Our Gear Clock</font></p></center>
</ol>
<li><h2>Design of the Project</h2></li>
<ol>
<li><b>Original Design</b></li>
In our original design, we intended to have a perfect perpetual motion machine that drives the gear clock.
<center><img src="./images/project.png"></center>
<center><p><font size="3">Figure 4: Our Original Design</font></p></center>
<li><b>Final Design and Changes made in the original design</b></li>
In our final design, we added a motor to our perpetual wheel to move it at a constant angular velocity of <i>pi/5 rad/sec</i>. We also moved the position of the gears to make them visible (Since they were of same size and would not be visible if one was over the other).
<center><img src="./images/final.png"></center>
<center><p><font size="3">Figure 5: Our Final Design</font></p></center>
<li><b>Reasons for modification of our original design</b></li>
We had tried lot of possible combinations of the dimensions (mass, radius, length, gravity) of each body of the perpetual wheel to make it move perpetually, but could not as we were bound to keep restitution of the bodies 0. This resulted in loss of energy and hence our wheel stopped rather earlier than expected. Hence, we added a motor to it to drive it at a uniform angular velocity.
</ol>
<li><h2>Analysis of code</h2></li>
<ol>
<li><b>Timing of the code</b></li>
Step time is the time taken for each iteration and the loop time is the total time taken for all the iterations since we are calculating the difference between the times of start of the loop and end of the loop to calculate the loop time. To calculate the step time we use an inbuilt function which gives the time taken for each step. Clearly the loop time is much larger than the step time because its is roughly the cumulative sum of the step times.<br>
We analysed our code based on the average time taken over the number of iterations and plotted various graphs. We get a pretty uniform curve apart from the frequent spikes. This happens because after specific time intervals which denote the extra time taken for calculating the motion of the gears in the clock, due to contact/collisions. These are the graphs of the time taken for each step, velocity update, position update, collision update varied over the number of iterations.
<center><img src="./images/plot1.jpg"></center>
<center><p><font size="3">Figure 6: Plot of Average loop time vs No. of iterations</font></p></center>
As seen in the first plot, the graph of step time is not even visible when plotted with the loop time. Also the loop time increases roughly with the increase in the number of iterations.
<center><img src="./images/plot2.jpg"></center>
<center><p><font size="3">Figure 7: Plot of Average update time vs No. of iterations</font></p></center>
Next, in plot 2 we plotted the Step time, collision time, velocity time, position time and the sum of collision, velocity and position time against the number of iterations. First interesting thing to notice is that the step time is very high till around the first 30 iterations. The reason behind it is the heavy functions called by Box2D to initialize the body, joint and fixture objects etc. and all the preprocessing that is done by Box2D for calculating the parameters (e.g AABB ,contact manifolds) which can be updated easily and are useful to make the simulation efficient in the future iterations.
<br>
We also note that the velocity time is greater than the position time and collision time. This is because velocity iterations also involve the calculations and updates of some body parameters.
<center><img src="./images/plot3.jpg"></center>
<center><p><font size="3">Figure 8: Plot of Frequency vs Time</font></p></center>
<center><img src="./images/plot4.jpg"></center>
<center><p><font size="3">Figure 9: Plot of Average step time vs No. of iterations</font></p></center>
Plot 3 and plot 4 were plotted for the error analysis of the data. In plot 3, we notice that the value of error is high initially,varies in between (even though the variations are very small they are noticeable) and becomes stable towards the end.This is due to the changing state of the CPU. Since we opened and closed different programs on the CPU while running the process, it shows the variations. In plot 4 we run the the simulation 84 times and analyse the step time for the 84<sup>th</sup> iteration.
<center><img src="./images/plot5.jpg"></center>
<center><p><font size="3">Figure 10: Plot of Average step time vs No. of iterations</font></p></center>
Plot 5 was plotted taking random sample points to examine their values.
<li><b>Profiling</b></li>
We ran the simulation using different Box2D compile parameters, one using <i>Release</i> and the other using <i>Debug</i> mode and did Profile analysis for both methods.<br>
We see that different functions take different proportion of the total time in the two modes. This is because in Release mode, the <i>-O3</i> option along with <i>g++</i> command optimises the run time, where 3 denotes the level of optimisation (i.e., -O3 does more optimisation than -O2), but sacrifices on the compile time. So if a function is called more number of times in the code, it will be a better candidate for optimisation, hence the difference in the proportion of time taken by each function in the two modes.<br>
We also notice that the event count in <i>Debug</i> mode is around 8 times the event count in <i>Release</i> mode since the <i>Debug</i> mode compiler additionally performs calls to debugging functions.
<center><img src="./images/release_mode.png"></center> 
<center><p><font size="3">Figure 11: Proportion of total time taken by few processes in <i>Release</i> mode (10,000 iterations)</font></p></center>
<center><img src="./images/debug_mode.png"></center> 
<center><p><font size="3">Figure 12: Proportion of total time taken by few processes in <i>Debug</i> mode (10,000 iterations)</font></p></center>
From the above results, we infer that the function <i>b2DynamicTree::Query< b2BroadPhase >(...)</i> takes the maximum proportion of the total loop time in Release mode, while the call to <i>__mcount_internal</i> takes the maximum proportion of the total loop time in Debug mode.
<center><img src="./images/release_cg.png"></center> 
<center><p><font size="3">Figure 13: Call Graph for <i>Release</i> mode : 10000 iterations</font></p></center>
<center><img src="./images/debug_cg.png"></center> 
<center><p><font size="3">Figure 14: Call Graph for <i>Debug</i> mode : 10000 iterations</font></p></center>
We observe that in general, the number of states/nodes in the call graph of the <i>Debug</i> mode is greater than the number of states/nodes in the call graph of the <i>Release</i> mode. This is because there was optimisation done in <i>Release</i> mode, and also because extra calls to debugging functions are called because the mode is <i>Debug</i>, which generates additional data to aid debugging.
</ol>
</font></ul>
</body>
</html>